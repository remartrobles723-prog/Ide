/*
 *  This file is part of AndroidTC.
 *
 *  AndroidTC is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AndroidTC is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with AndroidTC.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 ** @author Mohammed-baqer-null @ https://github.com/Mohammed-baqer-null
 */

package com.tom.androidcodestudio.project.manager.builder.toplevel

import java.io.File

/** Enum representing supported Gradle file types. */
enum class GradleFileType(val extension: String, val fileName: String) {
  GROOVY("gradle", "build.gradle"),
  KTS("gradle.kts", "build.gradle.kts"),
}

/**
 * Data class representing a Gradle plugin configuration.
 *
 * @property id The plugin ID (e.g., "com.android.application" or
 *   "libs.plugins.android.application")
 * @property version Optional version string (only used for non-catalog plugins)
 * @property apply Whether to apply the plugin immediately (default: false for top-level)
 * @property useAlias Whether to use version catalog alias (default: true)
 */
data class GradlePlugin(
    val id: String,
    val version: String? = null,
    val apply: Boolean = false,
    val useAlias: Boolean = true,
)

/** Interface for writing top-level Gradle build files. */
interface TLGradle {

  /**
   * Generates the top-level build.gradle file content.
   *
   * @param fileType The type of Gradle file (Groovy or KTS)
   * @param plugins List of plugins to include in the build file
   * @param includeCleanTask Whether to include the clean task (default: true)
   * @return The generated build file content as a String
   */
  fun generate(
      fileType: GradleFileType,
      plugins: List<GradlePlugin>,
      includeCleanTask: Boolean = true,
  ): String

  /**
   * Writes the generated content to a file.
   *
   * @param outputDir The directory where the build file will be created
   * @param fileType The type of Gradle file (Groovy or KTS)
   * @param plugins List of plugins to include in the build file
   * @param includeCleanTask Whether to include the clean task (default: true)
   * @return The created File object
   */
  fun writeToFile(
      outputDir: File,
      fileType: GradleFileType,
      plugins: List<GradlePlugin>,
      includeCleanTask: Boolean = true,
  ): File
}

/** Default implementation of TLGradle for generating top-level Gradle build files. */
class TopLevelGradleWriter : TLGradle {

  override fun generate(
      fileType: GradleFileType,
      plugins: List<GradlePlugin>,
      includeCleanTask: Boolean,
  ): String {
    return when (fileType) {
      GradleFileType.GROOVY -> generateGroovy(plugins, includeCleanTask)
      GradleFileType.KTS -> generateKts(plugins, includeCleanTask)
    }
  }

  override fun writeToFile(
      outputDir: File,
      fileType: GradleFileType,
      plugins: List<GradlePlugin>,
      includeCleanTask: Boolean,
  ): File {
    if (!outputDir.exists()) {
      outputDir.mkdirs()
    }

    val content = generate(fileType, plugins, includeCleanTask)
    val file = File(outputDir, fileType.fileName)
    file.writeText(content)

    return file
  }

  /** Generates Groovy-style build.gradle content. */
  private fun generateGroovy(plugins: List<GradlePlugin>, includeCleanTask: Boolean): String {
    val builder = StringBuilder()

    // Header comment
    builder.appendLine(
        "// Top-level build file where you can add configuration options common to all sub-projects/modules."
    )

    // Plugins block
    if (plugins.isNotEmpty()) {
      builder.appendLine("plugins {")
      builder.appendLine("    // Plugins automatically generated by TLGradle.kt")

      plugins.forEach { plugin ->
        val pluginLine = buildGroovyPluginLine(plugin)
        builder.appendLine("    $pluginLine")
      }

      builder.appendLine("}")
    }

    // Clean task
    if (includeCleanTask) {
      if (plugins.isNotEmpty()) {
        builder.appendLine()
      }
      builder.appendLine("tasks.register('clean', Delete) {")
      builder.appendLine("    delete rootProject.buildDir")
      builder.appendLine("}")
    }

    return builder.toString()
  }

  /** Generates Kotlin DSL-style build.gradle.kts content. */
  private fun generateKts(plugins: List<GradlePlugin>, includeCleanTask: Boolean): String {
    val builder = StringBuilder()

    // Header comment
    builder.appendLine(
        "// Top-level build file where you can add configuration options common to all sub-projects/modules."
    )

    // Plugins block
    if (plugins.isNotEmpty()) {
      builder.appendLine("plugins {")
      builder.appendLine("    // Plugins automatically generated by TLGradle.kt")

      plugins.forEach { plugin ->
        val pluginLine = buildKtsPluginLine(plugin)
        builder.appendLine("    $pluginLine")
      }

      builder.appendLine("}")
    }

    // Clean task
    if (includeCleanTask) {
      if (plugins.isNotEmpty()) {
        builder.appendLine()
      }
      builder.appendLine("tasks.register<Delete>(\"clean\") {")
      builder.appendLine("    delete(rootProject.layout.buildDirectory)")
      builder.appendLine("}")
    }

    return builder.toString()
  }

  /** Builds a Groovy plugin declaration line. */
  private fun buildGroovyPluginLine(plugin: GradlePlugin): String {
    return if (plugin.useAlias) {
      val applyClause = if (plugin.apply) "" else " apply false"
      "alias(libs.plugins.${plugin.id})$applyClause"
    } else {
      val idClause = "id '${plugin.id}'"
      val versionClause = plugin.version?.let { " version '$it'" } ?: ""
      val applyClause = if (plugin.apply) "" else " apply false"
      "$idClause$versionClause$applyClause"
    }
  }

  /** Builds a Kotlin DSL plugin declaration line. */
  private fun buildKtsPluginLine(plugin: GradlePlugin): String {
    return if (plugin.useAlias) {
      val applyClause = if (plugin.apply) "" else " apply false"
      "alias(libs.plugins.${plugin.id})$applyClause"
    } else {
      val idClause = "id(\"${plugin.id}\")"
      val versionClause = plugin.version?.let { " version \"$it\"" } ?: ""
      val applyClause = if (plugin.apply) "" else " apply false"
      "$idClause$versionClause$applyClause"
    }
  }
}

/** Builder class for creating GradlePlugin instances with a fluent API. */
class GradlePluginBuilder {
  private var id: String = ""
  private var version: String? = null
  private var apply: Boolean = false
  private var useAlias: Boolean = true

  fun id(id: String) = apply { this.id = id }

  fun version(version: String?) = apply { this.version = version }

  fun apply(apply: Boolean) = apply { this.apply = apply }

  fun useAlias(useAlias: Boolean) = apply { this.useAlias = useAlias }

  fun build(): GradlePlugin {
    require(id.isNotBlank()) { "Plugin ID cannot be blank" }
    return GradlePlugin(id, version, apply, useAlias)
  }
}

/** DSL function for creating GradlePlugin instances. */
fun gradlePlugin(block: GradlePluginBuilder.() -> Unit): GradlePlugin {
  return GradlePluginBuilder().apply(block).build()
}
